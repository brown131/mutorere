<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>FRP.Yampa.Switches</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">Yampa-0.11.1: Library for programming hybrid systems.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Antony Courtney and Henrik Nilsson Yale University 2003</td></tr><tr><th>License</th><td>BSD-style (see the LICENSE file in the distribution)</td></tr><tr><th>Maintainer</th><td>ivan.perez@keera.co.uk</td></tr><tr><th>Stability</th><td>provisional</td></tr><tr><th>Portability</th><td>non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">FRP.Yampa.Switches</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Basic switching</a></li><li><a href="#g:2">Parallel composition/switching (collections)</a><ul><li><a href="#g:3">With broadcasting</a></li><li><a href="#g:4">With helper routing function</a></li></ul></li><li><a href="#g:5">Parallel composition/switching (lists)</a><ul><li><a href="#g:6">With &quot;zip&quot; routing</a></li><li><a href="#g:7">With replication</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Switches allow you to change the signal function being applied.</p><p>The basic idea of switching is fromed by combining a subordinate signal function
 and a signal function continuation parameterised over some initial data.</p><p>For example, the most basic switch has the following signature:</p><pre>switch :: SF a (b, Event c) -&gt; (c -&gt; SF a b) -&gt; SF a b</pre><p>which indicates that it has two parameters: a signal function
 that produces an output and indicates, with an event, when it is time to
 switch, and a signal function that starts with the residual data left by the
 first SF in the event and continues onwards.</p><p>Switching occurs, at most, once. If you want something to switch repeatedly,
 in general, you need to loop, or to switch onto the same signal function
 again. However, some switches, explained below, are immediate (meaning that
 the second SF is started at the time of switching). If you use the same SF
 that originally provoked the switch, you are very likely to fall into an
 infinite loop. In those cases, the use of <code><a href="FRP-Yampa-Switches.html#v:dSwitch" title="FRP.Yampa.Switches">dSwitch</a></code> or <code><a href="FRP-Yampa-Basic.html#v:-45--45--62-" title="FRP.Yampa.Basic">--&gt;</a></code> may help.</p><p>Switches vary depending on a number of criterions:</p><ul><li><em>Decoupled</em> vs normal switching <em>(d)</em>: when an SF is being applied and a
 different SF needs to be applied next, one question is which one is used
 for the time in which the switching takes place. In decoupled switching, the
 old SF is used for the time of switching, and the one SF is only used after
 that. In normal or instantaneous or coupled switching, the old SF is
 discarded immediately and a new SF is used for the output already from that
 point in time.</li><li>How the switching event is provided <em>( /r/k)</em>: normally, an <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is
 used to indicate that a switching must take place. This event can be part of
 the argument SF (e.g., <code><a href="FRP-Yampa-Switches.html#v:switch" title="FRP.Yampa.Switches">switch</a></code>), it can be part of the input (e.g.,
 <code><a href="FRP-Yampa-Switches.html#v:rSwitch" title="FRP.Yampa.Switches">rSwitch</a></code>), or it can be determined by a second argument SF (e.g,
 <code><a href="FRP-Yampa-Switches.html#v:kSwitch" title="FRP.Yampa.Switches">kSwitch</a></code>).</li><li>How many SFs are being handled <em>( /p/par)</em>: some combinators deal with
 only one SF, others handle collections, either in the form of a
<code><a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a></code> or a list ('[]').</li><li>How the input is router <em>(B/Z/ )</em>: when multiple SFs are being combined,
 a decision needs to be made about how the input is passed to the internal
 SFs.  In some cases, broadcasting is used to pass the same input to all
 internal SFs. In others, the input is itself a collection, and each element
 is passed to one internal SF (i.e., <em>zipping</em>). In others, an auxiliary
 function is used to decide how to route specific inputs to specific SFs in
 the collection.</li></ul><p>These gives a number of different combinations, some of which make no sense,
 and also helps determine the expected behaviour of a combinator by looking
 at its name. For example, <code><a href="FRP-Yampa-Switches.html#v:drpSwitchB" title="FRP.Yampa.Switches">drpSwitchB</a></code> is the decoupled (<em>d</em>), recurrent
 (<em>r</em>), parallel (<em>p</em>) switch with broadcasting (<em>B</em>).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:switch">switch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (b, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b</li><li class="src short"><a href="#v:dSwitch">dSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (b, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b</li><li class="src short"><a href="#v:rSwitch">rSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b)) b</li><li class="src short"><a href="#v:drSwitch">drSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b)) b</li><li class="src short"><a href="#v:kSwitch">kSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b</li><li class="src short"><a href="#v:dkSwitch">dkSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b</li><li class="src short"><a href="#v:parB">parB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)</li><li class="src short"><a href="#v:pSwitchB">pSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)</li><li class="src short"><a href="#v:dpSwitchB">dpSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)</li><li class="src short"><a href="#v:rpSwitchB">rpSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b))) (col b)</li><li class="src short"><a href="#v:drpSwitchB">drpSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b))) (col b)</li><li class="src short"><a href="#v:par">par</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf)) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)</li><li class="src short"><a href="#v:pSwitch">pSwitch</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf)) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col c) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> d) -&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; d -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)</li><li class="src short"><a href="#v:dpSwitch">dpSwitch</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf)) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col c) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> d) -&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; d -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)</li><li class="src short"><a href="#v:rpSwitch">rpSwitch</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf)) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c))) (col c)</li><li class="src short"><a href="#v:drpSwitch">drpSwitch</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf)) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c))) (col c)</li><li class="src short"><a href="#v:parZ">parZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]</li><li class="src short"><a href="#v:pSwitchZ">pSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], [b]) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]</li><li class="src short"><a href="#v:dpSwitchZ">dpSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], [b]) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]</li><li class="src short"><a href="#v:rpSwitchZ">rpSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b])) [b]</li><li class="src short"><a href="#v:drpSwitchZ">drpSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b])) [b]</li><li class="src short"><a href="#v:parC">parC</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Basic switching</h1></a><div class="top"><p class="src"><a id="v:switch" class="def">switch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (b, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b <a href="#v:switch" class="selflink">#</a></p><div class="doc"><p>Basic switch.</p><p>By default, the first signal function is applied. Whenever the second value
 in the pair actually is an event, the value carried by the event is used to
 obtain a new signal function to be applied *at that time and at future
 times*. Until that happens, the first value in the pair is produced in the
 output signal.</p><p>Important note: at the time of switching, the second signal function is
 applied immediately. If that second SF can also switch at time zero, then a
 double (nested) switch might take place. If the second SF refers to the
 first one, the switch might take place infinitely many times and never be
 resolved.</p><p>Remember: The continuation is evaluated strictly at the time
 of switching!</p></div></div><div class="top"><p class="src"><a id="v:dSwitch" class="def">dSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (b, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b <a href="#v:dSwitch" class="selflink">#</a></p><div class="doc"><p>Switch with delayed observation.</p><p>By default, the first signal function is applied.</p><p>Whenever the second value in the pair actually is an event,
 the value carried by the event is used to obtain a new signal
 function to be applied *at future times*.</p><p>Until that happens, the first value in the pair is produced
 in the output signal.</p><p>Important note: at the time of switching, the second
 signal function is used immediately, but the current
 input is fed by it (even though the actual output signal
 value at time 0 is discarded).</p><p>If that second SF can also switch at time zero, then a
 double (nested) -- switch might take place. If the second SF refers to the
 first one, the switch might take place infinitely many times and never be
 resolved.</p><p>Remember: The continuation is evaluated strictly at the time
 of switching!</p></div></div><div class="top"><p class="src"><a id="v:rSwitch" class="def">rSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b)) b <a href="#v:rSwitch" class="selflink">#</a></p><div class="doc"><p>Recurring switch.</p><p>Uses the given SF until an event comes in the input, in which case the SF in
 the event is turned on, until the next event comes in the input, and so on.</p><p>See <a href="https://wiki.haskell.org/Yampa#Switches">https://wiki.haskell.org/Yampa#Switches</a> for more
 information on how this switch works.</p></div></div><div class="top"><p class="src"><a id="v:drSwitch" class="def">drSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b)) b <a href="#v:drSwitch" class="selflink">#</a></p><div class="doc"><p>Recurring switch with delayed observation.</p><p>Uses the given SF until an event comes in the input, in which case the SF in
 the event is turned on, until the next event comes in the input, and so on.</p><p>Uses decoupled switch (<code><a href="FRP-Yampa-Switches.html#v:dSwitch" title="FRP.Yampa.Switches">dSwitch</a></code>).</p><p>See <a href="https://wiki.haskell.org/Yampa#Switches">https://wiki.haskell.org/Yampa#Switches</a> for more
 information on how this switch works.</p></div></div><div class="top"><p class="src"><a id="v:kSwitch" class="def">kSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b <a href="#v:kSwitch" class="selflink">#</a></p><div class="doc"><p>Call-with-current-continuation switch.</p><p>Applies the first SF until the input signal and the output signal, when
 passed to the second SF, produce an event, in which case the original SF and
 the event are used to build an new SF to switch into.</p><p>See <a href="https://wiki.haskell.org/Yampa#Switches">https://wiki.haskell.org/Yampa#Switches</a> for more
 information on how this switch works.</p></div></div><div class="top"><p class="src"><a id="v:dkSwitch" class="def">dkSwitch</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b <a href="#v:dkSwitch" class="selflink">#</a></p><div class="doc"><p><code><a href="FRP-Yampa-Switches.html#v:kSwitch" title="FRP.Yampa.Switches">kSwitch</a></code> with delayed observation.</p><p>Applies the first SF until the input signal and the output signal, when
 passed to the second SF, produce an event, in which case the original SF and
 the event are used to build an new SF to switch into.</p><p>The switch is decoupled (<code><a href="FRP-Yampa-Switches.html#v:dSwitch" title="FRP.Yampa.Switches">dSwitch</a></code>).</p><p>See <a href="https://wiki.haskell.org/Yampa#Switches">https://wiki.haskell.org/Yampa#Switches</a> for more
 information on how this switch works.</p></div></div><a href="#g:2" id="g:2"><h1>Parallel composition/switching (collections)</h1></a><a href="#g:3" id="g:3"><h2>With broadcasting</h2></a><div class="top"><p class="src"><a id="v:parB" class="def">parB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b) <a href="#v:parB" class="selflink">#</a></p><div class="doc"><p>Spatial parallel composition of a signal function collection.
 Given a collection of signal functions, it returns a signal
 function that broadcasts its input signal to every element
 of the collection, to return a signal carrying a collection
 of outputs. See <code><a href="FRP-Yampa-Switches.html#v:par" title="FRP.Yampa.Switches">par</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:pSwitchB" class="def">pSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b) <a href="#v:pSwitchB" class="selflink">#</a></p><div class="doc"><p>Parallel switch (dynamic collection of signal functions spatially composed
 in parallel) with broadcasting. See <code><a href="FRP-Yampa-Switches.html#v:pSwitch" title="FRP.Yampa.Switches">pSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:dpSwitchB" class="def">dpSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col b) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b)) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col b) <a href="#v:dpSwitchB" class="selflink">#</a></p><div class="doc"><p>Decoupled parallel switch with broadcasting (dynamic collection of
   signal functions spatially composed in parallel). See <code><a href="FRP-Yampa-Switches.html#v:dpSwitch" title="FRP.Yampa.Switches">dpSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:rpSwitchB" class="def">rpSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b))) (col b) <a href="#v:rpSwitchB" class="selflink">#</a></p><div class="doc"><p>Recurring parallel switch with broadcasting.</p><p>Uses the given collection of SFs, until an event comes in the input, in
 which case the function in the <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is used to transform the collections
 of SF to be used with <code><a href="FRP-Yampa-Switches.html#v:rpSwitch" title="FRP.Yampa.Switches">rpSwitch</a></code> again, until the next event comes in the
 input, and so on.</p><p>Broadcasting is used to decide which subpart of the input goes to each SF in
 the collection.</p><p>See <code><a href="FRP-Yampa-Switches.html#v:rpSwitch" title="FRP.Yampa.Switches">rpSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:drpSwitchB" class="def">drpSwitchB</a> :: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col =&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b))) (col b) <a href="#v:drpSwitchB" class="selflink">#</a></p><div class="doc"><p>Decoupled recurring parallel switch with broadcasting.</p><p>Uses the given collection of SFs, until an event comes in the input, in
 which case the function in the <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is used to transform the collections
 of SF to be used with <code><a href="FRP-Yampa-Switches.html#v:rpSwitch" title="FRP.Yampa.Switches">rpSwitch</a></code> again, until the next event comes in the
 input, and so on.</p><p>Broadcasting is used to decide which subpart of the input goes to each SF in
 the collection.</p><p>This is the decoupled version of <code><a href="FRP-Yampa-Switches.html#v:rpSwitchB" title="FRP.Yampa.Switches">rpSwitchB</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><a href="#g:4" id="g:4"><h2>With helper routing function</h2></a><div class="top"><p class="src"><a id="v:par" class="def">par</a> <a href="#v:par" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf))</td><td class="doc"><p>Determines the input to each signal function
     in the collection. IMPORTANT! The routing function MUST
     preserve the structure of the signal function collection.</p></td></tr><tr><td class="src">-&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c)</td><td class="doc"><p>Signal function collection.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Spatial parallel composition of a signal function collection parameterized
 on the routing function.</p></div></div><div class="top"><p class="src"><a id="v:pSwitch" class="def">pSwitch</a> <a href="#v:pSwitch" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf))</td><td class="doc"><p>Routing function: determines the input to each signal function
   in the collection. IMPORTANT! The routing function has an
   obligation to preserve the structure of the signal function
   collection.</p></td></tr><tr><td class="src">-&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c)</td><td class="doc"><p>Signal function collection.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col c) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> d)</td><td class="doc"><p>Signal function generating the switching event.</p></td></tr><tr><td class="src">-&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; d -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c))</td><td class="doc"><p>Continuation to be invoked once event occurs.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Parallel switch parameterized on the routing function. This is the most
 general switch from which all other (non-delayed) switches in principle
 can be derived. The signal function collection is spatially composed in
 parallel and run until the event signal function has an occurrence. Once
 the switching event occurs, all signal function are &quot;frozen&quot; and their
 continuations are passed to the continuation function, along with the
 event value.</p></div></div><div class="top"><p class="src"><a id="v:dpSwitch" class="def">dpSwitch</a> <a href="#v:dpSwitch" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf))</td><td class="doc"><p>Routing function. Its purpose is
   to pair up each running signal function in the collection
   maintained by <code><a href="FRP-Yampa-Switches.html#v:dpSwitch" title="FRP.Yampa.Switches">dpSwitch</a></code> with the input it is going to see
   at each point in time. All the routing function can do is specify
   how the input is distributed.</p></td></tr><tr><td class="src">-&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c)</td><td class="doc"><p>Initial collection of signal functions.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, col c) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> d)</td><td class="doc"><p>Signal function that observes the external
   input signal and the output signals from the collection in order
   to produce a switching event.</p></td></tr><tr><td class="src">-&gt; (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; d -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c))</td><td class="doc"><p>The fourth argument is a function that is invoked when the
   switching event occurs, yielding a new signal function to switch
   into based on the collection of signal functions previously
   running and the value carried by the switching event. This
   allows the collection to be updated and then switched back
   in, typically by employing <code><a href="FRP-Yampa-Switches.html#v:dpSwitch" title="FRP.Yampa.Switches">dpSwitch</a></code> again.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a (col c)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Parallel switch with delayed observation parameterized on the routing
 function.</p><p>The collection argument to the function invoked on the
 switching event is of particular interest: it captures the
 continuations of the signal functions running in the collection
 maintained by <code><a href="FRP-Yampa-Switches.html#v:dpSwitch" title="FRP.Yampa.Switches">dpSwitch</a></code> at the time of the switching event,
 thus making it possible to preserve their state across a switch.
 Since the continuations are plain, ordinary signal functions,
 they can be resumed, discarded, stored, or combined with
 other signal functions.</p></div></div><div class="top"><p class="src"><a id="v:rpSwitch" class="def">rpSwitch</a> <a href="#v:rpSwitch" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf))</td><td class="doc"><p>Routing function: determines the input to each signal function
   in the collection. IMPORTANT! The routing function has an
   obligation to preserve the structure of the signal function
   collection.</p></td></tr><tr><td class="src">-&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c)</td><td class="doc"><p>Initial signal function collection.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c))) (col c)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Recurring parallel switch parameterized on the routing function.</p><p>Uses the given collection of SFs, until an event comes in the input, in
 which case the function in the <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is used to transform the collections
 of SF to be used with <code><a href="FRP-Yampa-Switches.html#v:rpSwitch" title="FRP.Yampa.Switches">rpSwitch</a></code> again, until the next event comes in the
 input, and so on.</p><p>The routing function is used to decide which subpart of the input
 goes to each SF in the collection.</p><p>This is the parallel version of <code><a href="FRP-Yampa-Switches.html#v:rSwitch" title="FRP.Yampa.Switches">rSwitch</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:drpSwitch" class="def">drpSwitch</a> <a href="#v:drpSwitch" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> col</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> sf. a -&gt; col sf -&gt; col (b, sf))</td><td class="doc"><p>Routing function: determines the input to each signal function
   in the collection. IMPORTANT! The routing function has an
   obligation to preserve the structure of the signal function
   collection.</p></td></tr><tr><td class="src">-&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c)</td><td class="doc"><p>Initial signal function collection.</p></td></tr><tr><td class="src">-&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> (a, <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> (col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c) -&gt; col (<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> b c))) (col c)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Recurring parallel switch with delayed observation parameterized on the
 routing function.</p><p>Uses the given collection of SFs, until an event comes in the input, in
 which case the function in the <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is used to transform the collections
 of SF to be used with <code><a href="FRP-Yampa-Switches.html#v:rpSwitch" title="FRP.Yampa.Switches">rpSwitch</a></code> again, until the next event comes in the
 input, and so on.</p><p>The routing function is used to decide which subpart of the input
 goes to each SF in the collection.</p><p>This is the parallel version of <code><a href="FRP-Yampa-Switches.html#v:drSwitch" title="FRP.Yampa.Switches">drSwitch</a></code>.</p></div></div><a href="#g:5" id="g:5"><h1>Parallel composition/switching (lists)</h1></a><a href="#g:6" id="g:6"><h2>With &quot;zip&quot; routing</h2></a><div class="top"><p class="src"><a id="v:parZ" class="def">parZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b] <a href="#v:parZ" class="selflink">#</a></p><div class="doc"><p>Parallel composition of a list of SFs.</p><p>Given a list of SFs, returns an SF that takes a list of inputs, applies
   each SF to each input in order, and returns the SFs' outputs.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embed (parZ [arr (+1), arr (+2)]) (deltaEncode 0.1 [[0, 0], [1, 1]])
</code></strong>[[1,2],[2,3]]
</pre><p>If there are more SFs than inputs, an exception is thrown.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embed (parZ [arr (+1), arr (+1), arr (+2)]) (deltaEncode 0.1 [[0, 0], [1, 1]])
</code></strong>[[1,1,*** Exception: FRP.Yampa.Switches.parZ: Input list too short.
</pre><p>If there are more inputs than SFs, the unused inputs are ignored.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embed (parZ [arr (+1)]) (deltaEncode 0.1 [[0, 0], [1, 1]])
</code></strong>[[1],[2]]
</pre></div></div><div class="top"><p class="src"><a id="v:pSwitchZ" class="def">pSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], [b]) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b] <a href="#v:pSwitchZ" class="selflink">#</a></p><div class="doc"><p>Parallel switch (dynamic collection of signal functions spatially composed
 in parallel). See <code><a href="FRP-Yampa-Switches.html#v:pSwitch" title="FRP.Yampa.Switches">pSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:dpSwitchZ" class="def">dpSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], [b]) (<a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> c) -&gt; ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; c -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b]) -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b] <a href="#v:dpSwitchZ" class="selflink">#</a></p><div class="doc"><p>Decoupled parallel switch with broadcasting (dynamic collection of
   signal functions spatially composed in parallel). See <code><a href="FRP-Yampa-Switches.html#v:dpSwitch" title="FRP.Yampa.Switches">dpSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:rpSwitchZ" class="def">rpSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b])) [b] <a href="#v:rpSwitchZ" class="selflink">#</a></p><div class="doc"><p>Recurring parallel switch with &quot;zip&quot; routing.</p><p>Uses the given list of SFs, until an event comes in the input, in which case
 the function in the <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is used to transform the list of SF to be used
 with <code><a href="FRP-Yampa-Switches.html#v:rpSwitchZ" title="FRP.Yampa.Switches">rpSwitchZ</a></code> again, until the next event comes in the input, and so on.</p><p>Zip routing is used to decide which subpart of the input goes to each SF in
 the list.</p><p>See <code><a href="FRP-Yampa-Switches.html#v:rpSwitch" title="FRP.Yampa.Switches">rpSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><div class="top"><p class="src"><a id="v:drpSwitchZ" class="def">drpSwitchZ</a> :: [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> ([a], <a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a> ([<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b] -&gt; [<a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b])) [b] <a href="#v:drpSwitchZ" class="selflink">#</a></p><div class="doc"><p>Decoupled recurring parallel switch with &quot;zip&quot; routing.</p><p>Uses the given list of SFs, until an event comes in the input, in which case
 the function in the <code><a href="FRP-Yampa-Event.html#t:Event" title="FRP.Yampa.Event">Event</a></code> is used to transform the list of SF to be used
 with <code><a href="FRP-Yampa-Switches.html#v:rpSwitchZ" title="FRP.Yampa.Switches">rpSwitchZ</a></code> again, until the next event comes in the input, and so on.</p><p>Zip routing is used to decide which subpart of the input goes to each SF in
 the list.</p><p>See <code><a href="FRP-Yampa-Switches.html#v:rpSwitchZ" title="FRP.Yampa.Switches">rpSwitchZ</a></code> and <code><a href="FRP-Yampa-Switches.html#v:drpSwitch" title="FRP.Yampa.Switches">drpSwitch</a></code>.</p><p>For more information on how parallel composition works, check
 <a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf">http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf</a></p></div></div><a href="#g:7" id="g:7"><h2>With replication</h2></a><div class="top"><p class="src"><a id="v:parC" class="def">parC</a> :: <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> [a] [b] <a href="#v:parC" class="selflink">#</a></p><div class="doc"><p>Apply an SF to every element of a list.</p><p>Example:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embed (parC integral) (deltaEncode 0.1 [[1, 2], [2, 4], [3, 6], [4.0, 8.0 :: Float]])
</code></strong>[[0.0,0.0],[0.1,0.2],[0.3,0.6],[0.6,1.2]]
</pre><p>The number of SFs or expected inputs is determined by the first input
   list, and not expected to vary over time.</p><p>If more inputs come in a subsequent list, they are ignored.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embed (parC (arr (+1))) (deltaEncode 0.1 [[0], [1, 1], [3, 4], [6, 7, 8], [1, 1], [0, 0], [1, 9, 8]])
</code></strong>[[1],[2],[4],[7],[2],[1],[2]]
</pre><p>If less inputs come in a subsequent list, an exception is thrown.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>embed (parC (arr (+1))) (deltaEncode 0.1 [[0, 0], [1, 1], [3, 4], [6, 7, 8], [1, 1], [0, 0], [1, 9, 8]])
</code></strong>[[1,1],[2,2],[4,5],[7,8],[2,2],[1,1],[2,10]]
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.20.0</p></div></body></html>