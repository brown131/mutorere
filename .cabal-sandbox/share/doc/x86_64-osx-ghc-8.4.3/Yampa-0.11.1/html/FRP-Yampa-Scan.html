<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>FRP.Yampa.Scan</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">Yampa-0.11.1: Library for programming hybrid systems.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">FRP.Yampa.Scan</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Simple, stateful signal processing.</p><p>Scanning implements elementary, step-based accumulating over signal
 functions by means of an auxiliary function applied to each input and to an
 accumulator. For comparison with other FRP libraries and with stream
 processing abstractions, think of fold.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:sscan">sscan</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b</li><li class="src short"><a href="#v:sscanPrim">sscanPrim</a> :: (c -&gt; a -&gt; <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c, b)) -&gt; c -&gt; b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:sscan" class="def">sscan</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b <a href="#v:sscan" class="selflink">#</a></p><div class="doc"><p>Applies a function point-wise, using the last output as next input. This
 creates a well-formed loop based on a pure, auxiliary function.</p></div></div><div class="top"><p class="src"><a id="v:sscanPrim" class="def">sscanPrim</a> :: (c -&gt; a -&gt; <a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (c, b)) -&gt; c -&gt; b -&gt; <a href="FRP-Yampa.html#t:SF" title="FRP.Yampa">SF</a> a b <a href="#v:sscanPrim" class="selflink">#</a></p><div class="doc"><p>Generic version of <code><a href="FRP-Yampa-Scan.html#v:sscan" title="FRP.Yampa.Scan">sscan</a></code>, in which the auxiliary function produces
 an internal accumulator and an &quot;held&quot; output.</p><p>Applies a function point-wise, using the last known <code><a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> output to form
 the output, and next input accumulator. If the output is <code><a href="file:///nix/store/d8hy7da75lpz3afn42wq6iyy43hvrgrv-ghc-8.4.3-doc/share/doc/ghc/html/libraries/base-4.11.1.0/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, the last
 known accumulators are used. This creates a well-formed loop based on a
 pure, auxiliary function.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.20.0</p></div></body></html>